// This file was generated by Slater.app - index.js


gsap.registerPlugin(ScrollTrigger, CustomEase, DrawSVGPlugin, TextPlugin, Draggable);

let loader = true;
let lenis;
let staggerDefault = 0.07;
let durationDefault = 1.47;
let transitionOffset = 25; /* ms */
const sunTransformText = $('.welcome-sun__transform').find('.chat-cloud__p').text();

CustomEase.create("cubic-default", "0.625, 0.05, 0, 1");
gsap.defaults({ease: "cubic-default", duration: durationDefault});

initPageTransitions();


// Animate rainbows function
function animateRainbow(selector, mode, count, duration = 4, delay = 0, stagger = 0.075, rainbowTimeline = null, scrollTriggerConfig = null) {
  // if they passed a scrollTrigger config but no timeline, create it
  if (!rainbowTimeline && scrollTriggerConfig) {
    rainbowTimeline = gsap.timeline({ scrollTrigger: scrollTriggerConfig });
  }

  const paths  = document.querySelectorAll(selector + ' path');
  const isFrom = mode === 'fromStart' || mode === 'fromEnd';
  const draw   = mode.endsWith('Start') ? '0% 0%' : '100% 100%';

  for (let i = 0; i < count; i++) {
    const targets = [ paths[i], paths[i + count] ];
    const pos     = delay + i * stagger;

    if (rainbowTimeline) {
      rainbowTimeline[isFrom ? 'from' : 'to'](
        targets,
        { drawSVG: draw, duration: duration, ease: "Power1.easeOut" },
        pos
      );
    } else {
      gsap[isFrom ? 'from' : 'to'](
        targets,
        { drawSVG: draw, duration: duration, delay: pos, ease: "Power2.easeInOut" }
      );
    }
  }
}

function rainbowsScrolltrigger() {
  // Activate rainbow scrolltrigger after 3s (When loader is done)
  // animateRainbow('.rainbow-sides__right', 'toStart', 4, 0.75, 0.25, 0.075, null, {trigger: '.stacked-cards__collection', start: 'center 90%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-sides__left', 'toEnd', 4, 0.75, 0, 0.075, null, {trigger: '.stacked-cards__collection', start: 'center 90%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-vertical__1', 'fromStart', 9, 1, 0.5, 0.075, null, {trigger: '.stacked-cards__collection', start: 'center 90%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-vertical__2', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__top', start: 'center 90%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-vertical__3', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__bottom', start: 'center 90%', toggleActions: 'play none none reverse'});
  
  // animateRainbow('.rainbow-sides__right', 'toStart', 4, 0.75, 0.125, 0.075, null, {trigger: '.stacked-cards__collection', start: 'clamp(top bottom)', end: 'bottom top', scrub: 0});
  // animateRainbow('.rainbow-sides__left', 'toEnd', 4, 0.75, 0, 0.075, null, {trigger: '.stacked-cards__collection', start: 'clamp(top bottom)', end: 'bottom top', scrub: 0});
  // animateRainbow('.rainbow-vertical__1', 'fromStart', 9, 0.75, 0.25, 0.075, null, {trigger: '.stacked-cards__collection', start: 'clamp(top bottom)', end: 'bottom top', scrub: 0});
  // animateRainbow('.rainbow-vertical__2', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__top', start: 'top bottom', end: 'bottom top', scrub: 0});
  // animateRainbow('.rainbow-vertical__3', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__bottom', start: 'top bottom', end: 'bottom top', scrub: 0});
  
  // animateRainbow('.rainbow-sides__right', 'toStart', 4, 0.75, 0, 0.075, null, {trigger: '.stacked-cards__collection', start: 'center 75%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-sides__left', 'toEnd', 4, 0.75, 0, 0.075, null, {trigger: '.stacked-cards__collection', start: 'center 75%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-vertical__1', 'fromStart', 9, 1, 0, 0.075, null, {trigger: '.stacked-cards__collection', start: 'center 75%', toggleActions: 'play none none reverse'});
  // animateRainbow('.rainbow-vertical__1-scrub', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__top', start: '-100% 100%', end: '-50% 50%', scrub: 0});
  // animateRainbow('.rainbow-vertical__2', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__top', start: 'top 100%', end: 'bottom 50%', scrub: 0});
  // animateRainbow('.rainbow-vertical__3', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__bottom', start: 'top 100%', end: 'bottom 50%', scrub: 0});
  
  animateRainbow('.rainbow-sides__right', 'toStart', 4, 0.75, 0.125, 0.075, null, {trigger: '.stacked-cards__collection', start: 'clamp(top bottom)', end: 'bottom top', scrub: 0});
  animateRainbow('.rainbow-sides__left', 'toEnd', 4, 0.75, 0, 0.075, null, {trigger: '.stacked-cards__collection', start: 'clamp(top bottom)', end: 'bottom top', scrub: 0});
  animateRainbow('.rainbow-vertical__1', 'fromStart', 9, 0.5, 0, 0.0375, null, {trigger: '.welcome', start: 'clamp(top bottom)',  endTrigger: ".about__tile", end: 'bottom bottom', scrub: 0});
  animateRainbow('.rainbow-vertical__3', 'fromStart', 9, 0.5, 0, 0.075, null, {trigger: '.about__bottom', start: 'top 100%', end: 'bottom 50%', scrub: 0});
}

// Animation - Page Loader
function initLoaderShort() {
  
  var tl = gsap.timeline();
  
  tl.call(function () {
    lenis.stop();
  }, null, 0);

  tl.call(function () {
    pageTransitionOut();
    rainbowsScrolltrigger();
  }, null, 0);
  
  tl.set($('.loading-screen'), {
    autoAlpha: 0,
  });
}
  

// Animation - Page Loader
function initLoader() {

  var tl = gsap.timeline();
  
  tl.set($('main'), {
    overflow: "clip",
    height: "100svh"
  });

  // Set te sun
  tl.set($('.welcome-sun__transform'), {
    y: () => {
      const h = $(window).height();
      const elH = $('.welcome-sun__transform').outerHeight();
      const top = $('.welcome-sun__transform').offset().top - $(window).scrollTop();
      return (h - elH)/2 - top;
    }
  });
  
  tl.set($('.welcome-sun__transform .chat-cloud__p'), {
    text: "...",
  });
  
  tl.to($('.loading-screen'), {
    autoAlpha: 0,
    duration: 0.3,
    ease: "none",
    delay: 0.1
  });
  
  tl.to($('.welcome-sun__transform .chat-cloud__p'), {
    duration: 0.4,
    text: "Hi Doctors!",
    ease: "none",
    delay: 0.2
  });
  
  tl.to($('.welcome-sun__transform .chat-cloud__p'), {
    duration: 0.25,
    text: "...",
    ease: "none",
    delay: 1,
  });
  
  tl.to($('.welcome-sun__transform .chat-cloud__p'), {
    duration: 0.5,
    text: "MedYouth is here...",
    ease: "none",
  });
  
  tl.to($('.welcome-sun__transform .chat-cloud__p'), {
    duration: 0.25,
    text: "...",
    ease: "none",
    delay: 1,
  });
  
  tl.to($('.welcome-sun__transform .chat-cloud__p'), {
    duration: 0.5,
    text: sunTransformText,
    ease: "none",
  });
  
  tl.to($('.welcome-sun__transform'), {
    y: 0,
  }, "< -1");
  
  tl.from($('.nav-bar'), {
    yPercent: -102,
  }, "<");
  
  tl.from($('.welcome__row-cards'), {
    duration: 1,
    y: "3em",
    autoAlpha: 0,
    stagger: -0.025,
    ease: "Expo.easeOut"
  }, "< 0.5")
  
  tl.from($('.welcome__h1 > span, .welcome__h2-box-wrap'), {
    duration: 1,
    yPercent: 100,
    autoAlpha: 0,
    stagger: -0.025,
    ease: "Expo.easeOut",
  }, "< 0.0025")
  
  tl.call(function () {
    lenis.stop();
  }, null, 0);

  // 4 pairs, 3s each, starting at 0.5s, 0.075s stagger
  animateRainbow('.rainbow-sides__right', 'fromStart', 4, 2, 0.5, 0.075);
  animateRainbow('.rainbow-sides__left', 'fromEnd', 4, 2, 1, 0.075);

  tl.call(function () {
    pageTransitionOut();
    
    gsap.set($('main'), {
      clearProps: "all"
    });
    
    rainbowsScrolltrigger();
  }, null, 3);
}

// Animation - Page Leave
function pageTransitionIn() {
  var tl = gsap.timeline();

  if (document.querySelector('.lorem-ipsum')) {}

  tl.call(function () {
    lenis.stop();
  });
  
}

// Animation - Page Enter
function pageTransitionOut() {
  var tl = gsap.timeline();

  tl.call(function () {
    lenis.start();
  }, null, 0);

}

function initPageTransitions() {

  // # Common: leave (Before Offset)
  async function commonLeaveBeforeOffset(data) {
    pageTransitionIn(data.current);
    initBasicFunctions();
    $('[data-navigation-status]').attr('data-navigation-status', 'not-active');
  }

  // # Common: leave (After Offset)
  async function commonLeaveAfterOffset(data) {
    lenis.destroy();
    killAllScrollTriggers();
    data.current.container.remove();
    $('[data-navigation-status]').attr('data-navigation-status', 'not-active');
    $('[data-scrolling-direction]').attr('data-scrolling-direction', 'down');
    $('[data-scrolling-started]').attr('data-scrolling-started', 'false');
  }

  // # Common: enter
  async function commonEnter(data) {
    initBarbaNavUpdate(data);
    pageTransitionOut(data.next);
  }

  // # Common: beforeEnter
  async function commonBeforeEnter(data) {
    ScrollTrigger.getAll().forEach(t => t.kill());
    // initResetWebflow(data);
    initSmoothScroll(data.next.container);
    initScript();
  }

  // # Common: afterEnter
  async function commonAfterEnter(data) {
    window.scrollTo(0, 0);
    ScrollTrigger.refresh();
  }

  barba.init({
    sync: true,
    debug: true,
    timeout: 7000,
    preventRunning: true,
    prevent: function ({ el }) {
      if (el.hasAttribute("data-barba-prevent")) {
        return true;
      }
    },
    transitions: [{
      name: 'self',
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }, {
      name: 'default',
      once(data) {
        document.fonts.ready.then(function () {
          initSmoothScroll(data.next.container);
          initScript();
          if (loader === true) {
            initLoader();
          } else {
            initLoaderShort();
          }
        });;
      },
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }]
  });

  function initSmoothScroll(container) {
    initLenis();
    ScrollTrigger.refresh();
  }

  // Function to kill all ScrollTrigger data
  function killAllScrollTriggers() {
    if (typeof ScrollTrigger !== 'undefined') {
      ScrollTrigger.killAll(); // Kill all ScrollTrigger instances
    }
  }

  // Reset scroll on page next
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
  }
}

function initLenis() {

  // Lenis: https://github.com/studio-freight/lenis
  lenis = new Lenis({
    // duration: 1,
    lerp: 0.165,
    wheelMultiplier: 1.25,
  });

  lenis.on('scroll', ScrollTrigger.update);

  gsap.ticker.add((time) => {
    lenis.raf(time * 1000);
  });

  gsap.ticker.lagSmoothing(0);
  
}

// Don't touch
function delay(n) {
  n = n || 2000;
  return new Promise((done) => {
    setTimeout(() => {
      done();
    }, n);
  });
}

/**
 * Fire all scripts on page load
 */
function initScript() {
  initCheckWindowHeight();
  initBasicFunctions();
  initStackedCardsDrag();
  initSunnyFollowMouse();
  initLenisCheckScrollUpDown();
  initScrollToAnchorLenis();
  initCSSMarquee();
  initStickyCursor();
  initAccordionCSS();
}

/**
 * Reset Webflow
 */
function initResetWebflow(data) {
  let parser = new DOMParser();
  let dom = parser.parseFromString(data.next.html, "text/html");
  let webflowPageId = dom.querySelector("html").getAttribute("data-wf-page");
  document.documentElement.setAttribute("data-wf-page", webflowPageId);
  window.Webflow.destroy();
  window.Webflow.ready();
  // window.Webflow.require("ix2").init();
}

/**
 * Barba Update Links outside Main on page Transition
 */
function initBarbaNavUpdate(data) {

  const updateItems = $(data.next.html).find('[data-barba-update]');

  $('[data-barba-update]').each(function (index) {
    if ($(updateItems[index]).get(0)) {
      const newLinkStatus = $(updateItems[index]).get(0).getAttribute('data-link-status');
      $(this).attr('data-link-status', newLinkStatus);
    }
  });
}

/**
 * Window Inner Height Check
 */
function initCheckWindowHeight() {
  // https://css-tricks.com/the-trick-to-viewport-units-on-mobile/
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh-in-px', `${vh}px`);
}

/**
 * Basic Functions
 */
function initBasicFunctions() {
  
  // Toggle YT Modal
  $('[data-yt-modal-toggle="toggle"]').click(function () {
    if ($('[data-yt-modal-status]').attr('data-yt-modal-status') == 'not-active') {
      $('[data-yt-modal-status]').attr('data-yt-modal-status', 'active');
      lenis.stop();
    } else {
      $('[data-yt-modal-status]').attr('data-yt-modal-status', 'not-active');
      lenis.start();
    }
  });

  // Close YT Modal
  $('[data-yt-modal-toggle="close"]').click(function () {
    $('[data-yt-modal-status]').attr('data-yt-modal-status', 'not-active');
    lenis.start();
    
    // Stop YouTube iframe by resetting their src
    $('iframe[src*="youtube.com"]').each(function () {
      var $iframe = $(this);
      var src = $iframe.attr('src');
      $iframe.attr('src', '');    // Remove the source
      $iframe.attr('src', src);   // Re-add the source to stop playback
    });
  });

  // Key ESC - Close YT Modal
  $(document).keydown(function (e) {
    if (e.keyCode == 27) {
      if ($('[data-yt-modal-status]').attr('data-yt-modal-status') == 'active') {
        $('[data-yt-modal-status]').attr('data-yt-modal-status', 'not-active');
        lenis.start();
        
        // Stop YouTube iframe by resetting their src
        $('iframe[src*="youtube.com"]').each(function () {
          var $iframe = $(this);
          var src = $iframe.attr('src');
          $iframe.attr('src', '');    // Remove the source
          $iframe.attr('src', src);   // Re-add the source to stop playback
        });
      }
    }
  });
  
  // Show and hide Sunny on Scroll
  gsap.set(".sunny-fixed", { xPercent: -200 });
  ScrollTrigger.create({
    trigger: ".welcome__col-sun",
    start: "bottom top",
    endTrigger: ".footer",
    end: "top bottom",
    onToggle: self => {
      gsap.to(".sunny-fixed", {
        xPercent: self.isActive ? 0 : -200,
        duration: 1.2,
        ease: "expo.inOut"
      });
    }
  });
  
  // Fixed Sunny Text on Hover
  gsap.set(".sunny-fixed .chat-cloud", { autoAlpha: 0 });
  function showText() {
    
    gsap.set($('.sunny-fixed .chat-cloud__p'), {
      text: '...'
    });
    
    gsap.to($('.sunny-fixed .chat-cloud'), {
      duration: 0.2,
      autoAlpha: 1,
      ease: "none"
    });
    
    gsap.to($('.sunny-fixed .chat-cloud__p'), {
      duration: 0.5,
      text: sunTransformText,
      ease: "none",
      delay: 0.3,
    });
  }
  function hideText() {
    gsap.to($('.sunny-fixed .chat-cloud__p'), {
      duration: 0.3,
      text: "...",
      ease: "none"
    });
    
    gsap.to($('.sunny-fixed .chat-cloud'), {
      duration: 0.2,
      autoAlpha: 0,
      ease: "none",
      delay: 0.3
    });
  }

  // desktop: hover in/out
  $('.sunny-fixed .sun-chat-combo').on('mouseenter', showText).on('mouseleave', hideText);

  // mobile/touch: tap to show
  $('.sunny-fixed .sun-chat-combo').on('click touchstart', function(e) {
    e.stopPropagation(); // prevent immediate document handler
    showText();
  });

  // tap outside to hide
  $(document).on('click touchstart', function(e) {
    if (!$(e.target).closest($('.sunny-fixed .sun-chat-combo')).length) {
      hideText();
    }
  });
  
  gsap.fromTo($('.footer .sun'), { 
      yPercent: 50 
    }, {
      yPercent: 0,
      ease: 'none',
      scrollTrigger: {
        trigger: $('.footer'),
        start: 'top bottom',    // when footer top enters viewport
        end: 'bottom bottom',   // when footer bottom reaches bottom of viewport
        scrub: true
      }
    }
  );
  
  $('.about__tile').each(function () {
    let triggerElement = $(this);
    let targetElementGroup = $(this).find('.rotate-circle__list');
    let targetElementSingle = $(this).find('.rotate-circle__image');
    const rotateMin = -15;
    const rtatePlus = 15;

    let tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerElement,
        start: "0% 100%",
        end: "100% 0%",
        scrub: 0
      }
    });

    tl.fromTo(targetElementGroup, {
      rotate: rtatePlus
    },{
      rotate: rotateMin,
      ease: "linear",
    });
    
    tl.fromTo(targetElementSingle, {
      rotate: rotateMin
    },{
      rotate: rtatePlus,
      ease: "linear",
    }, "<");
  });
}

/**
 * Stacked Cards with Drag
 */
function initStackedCardsDrag() {
  $('[data-stacked-cards]').each(function() {

    // animation presets
    let easeBeforeRelease = { duration: 0.2, ease: 'Power2.easeOut' };
    let easeAfterRelease  = { duration: 1, ease: 'elastic.out(1,0.75)' };
    let activeDeg         = '3deg';
    let inactiveDeg       = '-3deg';

    const $container = $(this);
    const $list      = $container.find('[data-stacked-cards-list]');

    // Draggable instances & cached elements
    let dragFirst, dragSecond;
    let $firstItem, $secondItem, firstEl, secondEl;
    let full, t;

    function restack() {
      const $items = $list.children('[data-stacked-cards-item]');
      $items.removeClass('is--active is--second');
      $items.eq(0).css({ 'z-index': 3, transform: `rotate(${activeDeg})`, 'pointer-events': 'auto' }).addClass('is--active');
      $items.eq(1).css({ 'z-index': 2, transform: `rotate(${inactiveDeg})`, 'pointer-events': 'none' }).addClass('is--second');
      $items.eq(2).css({ 'z-index': 1, transform: `rotate(${activeDeg})` });
      $items.slice(3).css({ 'z-index': 0, transform: `rotate(${inactiveDeg})` });
    }

    function setupDraggables() {
      restack();

      // cache top two cards
      const $items = $list.children('[data-stacked-cards-item]');
      $firstItem   = $items.eq(0);
      $secondItem  = $items.eq(1);
      firstEl      = $firstItem.find('[data-stacked-cards-card]')[0];
      secondEl     = $secondItem.find('[data-stacked-cards-card]')[0];

      // compute thresholds
      const width = $firstItem.find('[data-stacked-cards-card]').outerWidth();
      full = width * 1.15;
      t    = width * 0.1;

      // kill old Draggables
      dragFirst?.kill();
      dragSecond?.kill();

      // --- First card draggable ---
      dragFirst = Draggable.create(firstEl, {
        type: 'x',
        cursor: 'inherit',
        activeCursor: 'inherit',
        onPress() {
          $firstItem.find('[data-stacked-cards-card]').addClass('is--dragging');
        },
        onRelease() {
          $firstItem.find('[data-stacked-cards-card]').removeClass('is--dragging');
        },
        onDrag() {
          let raw = this.x;
          if (Math.abs(raw) > full) {
            const over = Math.abs(raw) - full;
            raw = (raw > 0 ? 1 : -1) * (full + over * 0.1);
          }
          gsap.set(firstEl, { x: raw, rotation: 0 });
        },
        onDragEnd() {
          const x   = this.x;
          const dir = x > 0 ? 'right' : 'left';

          // hand control to second card
          this.disable?.();
          dragSecond?.enable?.();
          $firstItem.css('pointer-events', 'none');
          $secondItem.css('pointer-events', 'auto');

          if (Math.abs(x) <= t) {
            // small drag: just snap back
            gsap.to(firstEl, {
              x: 0, rotation: 0,
              ...easeBeforeRelease,
              onComplete: resetCycle
            });
          }
          else if (Math.abs(x) <= full) {
            flick(dir, false, x);
          }
          else {
            flick(dir, true);
          }
        }
      })[0];

      // --- Second card draggable ---
      dragSecond = Draggable.create(secondEl, {
        type: 'x',
        cursor: 'inherit',
        activeCursor: 'inherit',
        onPress() {
          $secondItem.find('[data-stacked-cards-card]').addClass('is--dragging');
        },
        onRelease() {
          $secondItem.find('[data-stacked-cards-card]').removeClass('is--dragging');
        },
        onDrag() {
          let raw = this.x;
          if (Math.abs(raw) > full) {
            const over = Math.abs(raw) - full;
            raw = (raw > 0 ? 1 : -1) * (full + over * 0.2);
          }
          gsap.set(secondEl, { x: raw, rotation: 0 });
        },
        onDragEnd() {
          gsap.to(secondEl, {
            x: 0, rotation: 0,
            ...easeBeforeRelease
          });
        }
      })[0];

      // start with first card active
      dragFirst?.enable?.();
      dragSecond?.disable?.();
      $firstItem.css('pointer-events', 'auto');
      $secondItem.css('pointer-events', 'none');
    }

    function flick(dir, skipHome = false, releaseX = 0) {
      if (!(dir === 'left' || dir === 'right')) {
        dir = activeDeg === '3deg' ? 'right' : 'left';
      }
      dragFirst?.disable?.();

      const $item = $list.children('[data-stacked-cards-item]').first();
      const $card = $item.find('[data-stacked-cards-card]');
      const exitX = dir === 'right' ? full : -full;

      if (skipHome) {
        const visualX = gsap.getProperty($card[0], 'x');
        $item.appendTo($list);
        [activeDeg, inactiveDeg] = [inactiveDeg, activeDeg];
        restack();
        gsap.fromTo(
          $card[0],
          { x: visualX, rotation: 0 },
          { x: 0, rotation: 0, ...easeAfterRelease, onComplete: resetCycle }
        );

      } else {
        gsap.fromTo(
          $card[0],
          { x: releaseX, rotation: 0 },
          {
            x: exitX,
            ...easeBeforeRelease,
            onComplete() {
              gsap.set($card[0], { x: 0, rotation: 0 });
              $item.appendTo($list);
              [activeDeg, inactiveDeg] = [inactiveDeg, activeDeg];
              resetCycle();
              gsap.fromTo(
                $item.find('[data-stacked-cards-card]')[0],
                { x: exitX },
                { x: 0, ...easeAfterRelease, onComplete: resetCycle }
              );
            }
          }
        );
      }
    }

    function resetCycle() {
      $list.find('[data-stacked-cards-card].is--dragging').removeClass('is--dragging');
      setupDraggables();
    }

    setupDraggables();

    // “Next” button support
    $container.find('[data-stacked-cards="next"]').off('click').on('click', () => flick());
  });
}

/**
 * Sunny Follow Mouse 
 */
function initSunnyFollowMouse() {
  const faces = $('[data-sunny-face]').map(function() {
    return {
      el:   this,
      setX: gsap.quickTo(this, 'xPercent', { duration: 0.4, ease: 'power3' }),
      setY: gsap.quickTo(this, 'yPercent', { duration: 0.4, ease: 'power3' })
    };
  }).get();

  window.addEventListener('mousemove', e => {
    const mx = e.clientX;
    const my = e.clientY;

    faces.forEach(face => {
      const r  = face.el.getBoundingClientRect();
      const cx = r.left + r.width  / 2;
      const cy = r.top  + r.height / 2;
      const rx = r.width  / 2;
      const ry = r.height / 2;

      // delta → raw normalized
      let nx = (mx - cx) / rx;
      let ny = (my - cy) / ry;

      // clamp to circle
      const mag = Math.hypot(nx, ny);
      if (mag > 1) {
        nx /= mag;
        ny /= mag;
      }

      const mappedX = nx * 66;
      const mappedY = ny * 66;

      face.setX(mappedX);
      face.setY(mappedY);
    });
  });
}


/**
 * Lenis - Check Scroll up or Down
 */

function initLenisCheckScrollUpDown() {

  var lastScrollTop = 0;
  var threshold = 50;
  var thresholdTop = 50;

  var scrollHandler = function (e) {
    var nowScrollTop = e.targetScroll;

    if (Math.abs(lastScrollTop - nowScrollTop) >= threshold) {

      // Check Scroll Direction
      if (nowScrollTop > lastScrollTop) {
        $("[data-scrolling-direction]").attr('data-scrolling-direction', 'down');
      } else {
        $("[data-scrolling-direction]").attr('data-scrolling-direction', 'up');
      }
      lastScrollTop = nowScrollTop;

      // Check if Scroll Started
      if (nowScrollTop > thresholdTop) {
        $("[data-scrolling-started]").attr('data-scrolling-started', 'true');
      } else {
        $("[data-scrolling-started]").attr('data-scrolling-started', 'false');
      }
    }
  };

  function startCheckScroll() {
    lenis.on('scroll', scrollHandler);
  }

  function stopCheckScroll() {
    lenis.off('scroll', scrollHandler);
  }

  // Initialize the scroll check
  startCheckScroll();

  // Cleanup before leaving the page
  barba.hooks.beforeLeave(() => {
    stopCheckScroll(); // Clean up the scroll event listeners
    lastScrollTop = 0; // Reset scroll tracking data
  });

  // Reinitialize after page transition
  barba.hooks.after(() => {
    startCheckScroll(); // Reattach the scroll event listeners
  });
}

/**
 * Lenis - ScrollTo Anchor Links
 */
function initScrollToAnchorLenis() {

  $("[data-anchor-target]").click(function () {

    let targetScrollToAnchorLenis = $(this).attr('data-anchor-target');
    lenis.scrollTo(targetScrollToAnchorLenis, {
      easing: (x) => (x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2),
      duration: 1,
      offset: 0
    });

  });
}

/**
 * CSS Marquee (Osmo)
 */
function initCSSMarquee() {
  const pixelsPerSecond = 75; // Set the marquee speed (pixels per second)
  const marquees = document.querySelectorAll('[data-css-marquee]');
  
  // Duplicate each [data-css-marquee-list] element inside its container
  marquees.forEach(marquee => {
    marquee.querySelectorAll('[data-css-marquee-list]').forEach(list => {
      const duplicate = list.cloneNode(true);
      marquee.appendChild(duplicate);
    });
  });

  // Create an IntersectionObserver to check if the marquee container is in view
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      entry.target.querySelectorAll('[data-css-marquee-list]').forEach(list => 
        list.style.animationPlayState = entry.isIntersecting ? 'running' : 'paused'
      );
    });
  }, { threshold: 0 });
  
  // Calculate the width and set the animation duration accordingly
  marquees.forEach(marquee => {
    marquee.querySelectorAll('[data-css-marquee-list]').forEach(list => {
      list.style.animationDuration = (list.offsetWidth / pixelsPerSecond) + 's';
      list.style.animationPlayState = 'paused';
    });
    observer.observe(marquee);
  });
}

/**
 * Sticky Cursor
 */
function initStickyCursor() {

  const is_touch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  if (is_touch) return;

  // percent offsets of the target’s own dimensions
  const offset_x_pct = 8;
  const offset_y_pct = 40;

  const instances = [];

  document.querySelectorAll('[data-sticky-cursor]').forEach(function(container) {
    const target = container.querySelector('[data-sticky-cursor-target]');
    if (!target) return;

    gsap.set(target, { x: 0, y: 0 });

    // initial measure
    const cont_rect = container.getBoundingClientRect();
    const tgt_rect  = target.getBoundingClientRect();
    let orig_x = tgt_rect.left - cont_rect.left;
    let orig_y = tgt_rect.top  - cont_rect.top;

    let is_inside  = false;
    let last_event = null;

    function animate_to(e) {
      const cR = container.getBoundingClientRect();
      const rel_x = e.clientX - cR.left;
      const rel_y = e.clientY - cR.top;

      // current target size
      const tR = target.getBoundingClientRect();
      const target_w = tR.width;
      const target_h = tR.height;

      const offset_x_px = (offset_x_pct / 100) * target_w;
      const offset_y_px = (offset_y_pct / 100) * target_h;

      gsap.to(target, {
        x: rel_x - orig_x + offset_x_px,
        y: rel_y - orig_y + offset_y_px,
        duration: 0.5,
        ease: 'Power3.easeOut',
        overwrite: 'auto'
      });
    }

    container.addEventListener('mouseenter', function(e) {
      is_inside  = true;
      last_event = e;
      animate_to(e);
    });
    container.addEventListener('mousemove', function(e) {
      last_event = e;
      animate_to(e);
    });
    container.addEventListener('mouseleave', function() {
      is_inside = false;
      gsap.to(target, {
        x: 0,
        y: 0,
        duration: 0.5,
        ease: 'cubic-default',
        overwrite: 'auto'
      });
    });

    instances.push({
      container: container,
      target:    target,
      get orig_x() { return orig_x; },
      set orig_x(v) { orig_x = v; },
      get orig_y() { return orig_y; },
      set orig_y(v) { orig_y = v; },
      is_inside: () => is_inside,
      get_last:  () => last_event
    });
  });

  // on scroll, re‐apply last animation if still hovering
  window.addEventListener('scroll', function() {
    instances.forEach(function(inst) {
      if (!inst.is_inside()) return;
      const e = inst.get_last();
      if (!e) return;
      animateOnScrollOrResize(inst, e);
    });
  });

  // on resize, recalc each orig_x/orig_y and re‐apply if needed
  window.addEventListener('resize', function() {
    instances.forEach(function(inst) {
      const cR = inst.container.getBoundingClientRect();
      const tR = inst.target.getBoundingClientRect();
      inst.orig_x = tR.left - cR.left;
      inst.orig_y = tR.top  - cR.top;

      if (inst.is_inside()) {
        const e = inst.get_last();
        if (e) animateOnScrollOrResize(inst, e);
      }
    });
  });

  // helper to reuse for scroll & resize
  function animateOnScrollOrResize(inst, e) {
    const cR = inst.container.getBoundingClientRect();
    const rel_x = e.clientX - cR.left;
    const rel_y = e.clientY - cR.top;
    const tR = inst.target.getBoundingClientRect();
    const target_w = tR.width;
    const target_h = tR.height;
    const offset_x_px = (offset_x_pct / 100) * target_w;
    const offset_y_px = (offset_y_pct / 100) * target_h;

    gsap.to(inst.target, {
      x: rel_x - inst.orig_x + offset_x_px,
      y: rel_y - inst.orig_y + offset_y_px,
      duration: 0.5,
      ease: 'Power3.easeOut',
      overwrite: 'auto'
    });
  }
}

/**
 * Accordion CSS (Osmo)
 */
function initAccordionCSS() {
  document.querySelectorAll('[data-accordion-css-init]').forEach((accordion) => {
    const closeSiblings = accordion.getAttribute('data-accordion-close-siblings') === 'true';

    accordion.addEventListener('click', (event) => {
      const toggle = event.target.closest('[data-accordion-toggle]');
      if (!toggle) return; // Exit if the clicked element is not a toggle

      const singleAccordion = toggle.closest('[data-accordion-status]');
      if (!singleAccordion) return; // Exit if no accordion container is found

      const isActive = singleAccordion.getAttribute('data-accordion-status') === 'active';
      singleAccordion.setAttribute('data-accordion-status', isActive ? 'not-active' : 'active');
      
      // When [data-accordion-close-siblings="true"]
      if (closeSiblings && !isActive) {
        accordion.querySelectorAll('[data-accordion-status="active"]').forEach((sibling) => {
          if (sibling !== singleAccordion) sibling.setAttribute('data-accordion-status', 'not-active');
        });
      }
    });
  });
}
